# 操作系统
## 为什么A-OS是一个操作系统
操作系统本身,实际上就是库函数+任务调度,在A-OS中,我们提供了两个库函数,并提供了两个方式进行任务调度,在最顶层的抽象上,这就是一个操作系统了.

通过这个操作系统,不断的驱动状态机的前进.

在某种意义上,这就是一个分时操作系统.

### 此操作系统的问题
代码丑陋难读,但是能run起来,满神奇的.

## EvAM and EvOS
### AM
提供15个API,操作系统实际上是在这15个API上构建的,
AM的本质是模拟一台物理上存在的计算机,用AM屏蔽掉底层X86或者RISC-V的复杂性.

我需要首先实现一个AM,然后才能在这个AM的基础上进行实验,实现操作系统.

换一种理解方式,AM本质上是一个lib,操作系统则是在这个lib上实现的Rust程序,而其他编写戴尔可执行文件,则是在操作系统这个程序上,实现的可执行程序.
在清华的rCore的早期实现中,我们把程序加载到rCore的内核当中,通过设置寄存器等等方式,让操作系统可以执行其他的应用程序,但是这里我们通过AM实现的虚拟机,并没有寄存器的概念,(似乎没有),所以并不能这样执行程序.

我实际的想法是,首先实现出AM这个虚拟物理机,然后再进行后续的操作.

现在的问题在于,AM虚拟物理机确实屏蔽掉了底层的复杂性,但是自己实现AM虚拟机的时候,还是不可避免的要面对这些复杂性,比如cli函数,halt函数,实际上是x86的汇编.

也就是说,我们自己实现的AM虚拟机,也离不开QEMU,最终还是需要运行在QEMU上,在其上执行相关的汇编代码,因为QEMU模拟了CPU中断等特征.


这是很困难的

### OS
实现步骤
1. 一个Self hosting的裸程序
2. 为自己的系统实现相关的Lib库
3. 